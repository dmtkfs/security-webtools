import React, { useMemo, useRef, useState } from 'react'
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Tooltip,
  Legend,
} from 'chart.js'
import { Line, Bar, Doughnut } from 'react-chartjs-2'
import {
  TIME_PRESETS,
  computeHistogram,
  filterEventsByRange,
  computeRangeFromPreset,
} from './timeWindow.js'

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Tooltip,
  Legend,
)

ChartJS.defaults.devicePixelRatio = 2

const COLOR_ENTITY_FILL = '#38bdf8'
const COLOR_ENTITY_BORDER = '#0ea5e9'

const COLOR_ALERT_FILL = '#fb7185'
const COLOR_ALERT_BORDER = '#f43f5e'


// ------------------------------------
// Reusable ChartCard with "Export PNG"
// ------------------------------------
function ChartCard({
  title,
  description,
  chartRef,
  filename,
  footerSummary,
  contextLabel,
  children,
}) {
  const handleExport = () => {
    if (!chartRef?.current) return

    const chartInstance = chartRef.current
    const srcCanvas = chartInstance.canvas || chartInstance.ctx?.canvas
    if (!srcCanvas) return

    const padding = 24
    const titleAreaHeight = 34
    const footerAreaHeight = 44

    const chartWidth = srcCanvas.width
    const chartHeight = srcCanvas.height

    const exportCanvas = document.createElement('canvas')
    exportCanvas.width = chartWidth + padding * 2
    exportCanvas.height =
      chartHeight + padding * 2 + footerAreaHeight + titleAreaHeight

    const ctx = exportCanvas.getContext('2d')
    if (!ctx) return

    ctx.fillStyle = '#020617'
    ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height)

    const centerX = exportCanvas.width / 2

    if (title) {
      ctx.textAlign = 'center'
      ctx.textBaseline = 'top'
      ctx.fillStyle = '#e5e7eb'
      ctx.font =
        '600 15px system-ui, -apple-system, BlinkMacSystemFont, sans-serif'
      ctx.fillText(title, centerX, padding + 2)
    }

    if (contextLabel) {
      ctx.textAlign = 'center'
      ctx.textBaseline = 'top'
      ctx.fillStyle = '#9ca3af'
      ctx.font =
        '10px system-ui, -apple-system, BlinkMacSystemFont, sans-serif'
      ctx.fillText(contextLabel, centerX, padding + 20)
    }

    const chartX = padding
    const chartY = padding + titleAreaHeight
    ctx.drawImage(srcCanvas, chartX, chartY)

    const summaryText =
      footerSummary && footerSummary.trim().length > 0 ? footerSummary : ''
    const marketingText = 'Generated by Security Webtools'

    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'

    const footerStartY = chartY + chartHeight + 12

    // Line 1: summary
    if (summaryText) {
      ctx.fillStyle = '#6ee7b7'
      ctx.font = 'italic 11px system-ui, -apple-system, BlinkMacSystemFont, sans-serif'
      ctx.fillText(summaryText, centerX, footerStartY)
    }

    // Line 2: marketing
    ctx.fillStyle = '#e5e7eb'
    ctx.font = 'italic 11px system-ui, -apple-system, BlinkMacSystemFont, sans-serif'
    ctx.fillText(marketingText, centerX, footerStartY + 22)

    exportCanvas.toBlob(
      (blob) => {
        if (!blob) return
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = filename || 'mini-siem-chart.png'
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      },
      'image/png',
      0.95,
    )
  }

  return (
    <div className="flex h-full flex-col rounded-2xl border border-slate-800 bg-slate-950/70 p-3">
      <div className="mb-2 flex items-start justify-between gap-2">
        <div>
          <div className="text-xs font-semibold text-slate-100">
            {title}
          </div>
          {description && (
            <p className="text-[0.65rem] text-slate-400">
              {description}
            </p>
          )}
        </div>
        <button
          type="button"
          onClick={handleExport}
          className="self-start rounded-full border border-slate-700 bg-slate-900/80 px-2.5 py-0.5 text-[0.65rem] text-slate-100 hover:border-emerald-500/70 hover:text-emerald-200"
        >
          Export PNG
        </button>
      </div>
      <div className="mt-1 min-h-[180px] flex-1">{children}</div>
    </div>
  )
}

// Map rule types to broader categories
const RULE_CATEGORY_LABELS = {
  'bruteforce.ip': 'Bruteforce patterns',
  'bruteforce.user': 'Bruteforce patterns',
  'suspicious-success.ip': 'Suspicious successes',
  'suspicious-success.user': 'Suspicious successes',
  'spray.ip': 'Password spraying',
  'noisy.ip': 'Noisy / scanner IPs',
  'geo.new-region': 'Geo anomalies',
  'geo.external-region': 'Geo anomalies',
  'auth.isolated-failure': 'Isolated failures',
}

function getRuleCategoryLabel(type) {
  if (!type) return 'Other types'
  return RULE_CATEGORY_LABELS[type] || 'Other types'
}

// Helpers
function formatBucketLabel(date, unit, from, to) {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) return ''
  const crossesYear =
  from instanceof Date &&
  to instanceof Date &&
  from.getFullYear() !== to.getFullYear()
  if (unit === 'second' || unit === 'minute' || unit === 'hour') {
    return date.toLocaleTimeString(undefined, {
      hour: '2-digit',
      minute: '2-digit',
    })
  }
  // Day/month-ish: show date
  return date.toLocaleDateString(undefined, {
    month: 'short',
    day: '2-digit',
    ...(crossesYear ? { year: 'numeric' } : {}),
  })
}

function formatBucketSizeLabel(sizeMs) {
  if (!sizeMs || !Number.isFinite(sizeMs)) return 'auto'

  const sec = sizeMs / 1000
  const min = sec / 60
  const hr = min / 60
  const day = hr / 24

  if (sizeMs === 7 * 24 * 60 * 60 * 1000) return '1 week'
  if (sizeMs === 30 * 24 * 60 * 60 * 1000) return '1 month'

  if (day >= 1 && Number.isInteger(day)) return `${day} day${day > 1 ? 's' : ''}`
  if (hr >= 1 && Number.isInteger(hr)) return `${hr} h`
  if (min >= 1 && Number.isInteger(min)) return `${min} min`
  if (sec >= 1 && Number.isInteger(sec)) return `${sec} s`

  // fallback for weird sizes
  if (day >= 1) return `${day.toFixed(1)} days`
  if (hr >= 1) return `${hr.toFixed(1)} h`
  return `${min.toFixed(1)} min`
}

const BUCKET_LABELS = {
  auto: 'Auto',
  '1m': '1 min',
  '2m': '2 min',
  '5m': '5 min',
  '10m': '10 min',
  '15m': '15 min',
  '30m': '30 min',
  '60m': '60 min',
  '2h': '2 hours',
  '6h': '6 hours',
  '12h': '12 hours',
  '1d': '1 day',
  '7d': '1 week',
  '30d': '1 month',
}

function hashHue(str) {
  let h = 0
  for (let i = 0; i < str.length; i++) {
    h = (h * 31 + str.charCodeAt(i)) >>> 0
  }
  return h % 360
}

function colorFromLabel(label, { s = 70, l = 55 } = {}) {
  const hue = hashHue(String(label || ''))
  return `hsl(${hue} ${s}% ${l}%)`
}

function splitTextLines(ctx, text, maxWidth) {
  if (!text) return []
  const words = String(text).split(/\s+/).filter(Boolean)

  const lines = []
  let line = ''

  for (const w of words) {
    const test = line ? `${line} ${w}` : w
    if (ctx.measureText(test).width <= maxWidth) {
      line = test
    } else {
      if (line) lines.push(line)
      line = w
    }
  }
  if (line) lines.push(line)
  return lines
}

function wrapText(
  ctx,
  text,
  x,
  y,
  maxWidth,
  lineHeight,
  maxLines = 2,
  align = 'center',
) {
  if (!text) return 0

  ctx.textAlign = align
  ctx.textBaseline = 'top'

  const words = String(text).split(/\s+/).filter(Boolean)
  const lines = []
  let line = ''

  for (const w of words) {
    const test = line ? `${line} ${w}` : w
    if (ctx.measureText(test).width <= maxWidth) {
      line = test
    } else {
      if (line) lines.push(line)
      line = w
      if (lines.length >= maxLines) break
    }
  }

  if (lines.length < maxLines && line) lines.push(line)

  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], x, y + i * lineHeight)
  }

  return lines.length
}

function formatLocalDateTime(d) {
  if (!(d instanceof Date) || Number.isNaN(d.getTime())) return ''
  return d.toLocaleString(undefined, {
    year: 'numeric',
    month: 'short',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}

// ----- Core -----

function MiniSiemOverviewTab({ events, alerts }) {
  const overviewRef = useRef(null)

  const [selectedPresetId, setSelectedPresetId] = useState('all')
  const [bucketSizeChoice, setBucketSizeChoice] = useState('auto')

  const safeEvents = useMemo(
    () => (Array.isArray(events) ? events : []),
    [events],
  )
  const safeAlerts = useMemo(
    () => (Array.isArray(alerts) ? alerts : []),
    [alerts],
  )

// 0) Base model: determine the selected window without bucket sizing
const windowRange = useMemo(() => {
  return computeRangeFromPreset(safeEvents, selectedPresetId)
}, [safeEvents, selectedPresetId])

// 1) Bucket size options based on selected window span
const bucketOptions = useMemo(() => {
  const from = windowRange.from
  const to = windowRange.to
  if (!from || !to) return ['auto']

  const spanMs = to.getTime() - from.getTime()
  const minute = 60 * 1000
  const hour = 60 * minute
  const day = 24 * hour

  // Bucket sizes
  const candidates = [
    { id: '1m', ms: 1 * minute },
    { id: '2m', ms: 2 * minute },
    { id: '5m', ms: 5 * minute },
    { id: '10m', ms: 10 * minute },
    { id: '15m', ms: 15 * minute },
    { id: '30m', ms: 30 * minute },
    { id: '60m', ms: 60 * minute },
    { id: '2h', ms: 2 * hour },
    { id: '6h', ms: 6 * hour },
    { id: '12h', ms: 12 * hour },
    { id: '1d', ms: 1 * day },
    { id: '7d', ms: 7 * day },
    { id: '30d', ms: 30 * day },
  ]

  // Keep bucket counts sane
  const MIN_BUCKETS = 6
  const MAX_BUCKETS = 720

  const opts = ['auto']

  for (const c of candidates) {
    const count = spanMs / c.ms
    if (count >= MIN_BUCKETS && count <= MAX_BUCKETS) {
      opts.push(c.id)
    }
  }

  // Fallbacks
  if (opts.length === 1) {
    if (spanMs <= 2 * hour) opts.push('1m', '5m', '15m')
    else if (spanMs <= 2 * day) opts.push('15m', '60m', '6h')
    else if (spanMs <= 14 * day) opts.push('6h', '12h', '1d')
    else if (spanMs <= 180 * day) opts.push('1d', '7d')
    else opts.push('7d', '30d')
  }

  return opts
  }, [windowRange.from, windowRange.to])

  // 2) Effective choice: NO setState
  const effectiveBucketChoice = useMemo(() => {
    return bucketOptions.includes(bucketSizeChoice) ? bucketSizeChoice : 'auto'
  }, [bucketOptions, bucketSizeChoice])

  // 3) Map effective choice to explicit ms (null = auto)
  const explicitBucketSizeMs = useMemo(() => {
    const minute = 60 * 1000
    const hour = 60 * minute
    const day = 24 * hour

    switch (effectiveBucketChoice) {
      case '1m':
        return 1 * minute
      case '2m': 
        return 2 * minute
      case '10m': 
        return 10 * minute
      case '30m': 
        return 30 * minute
      case '2h': 
        return 2 * hour
      case '5m':
        return 5 * minute
      case '15m':
        return 15 * minute
      case '60m':
        return 60 * minute
      case '6h':
        return 6 * hour
      case '12h':
        return 12 * hour
      case '1d':
        return 1 * day
      case '7d':
        return 7 * day
      case '30d':
        return 30 * day
      default:
        return null
    }
  }, [effectiveBucketChoice])

  // 4) Final histogram model
  const histogramModel = useMemo(() => {
    return computeHistogram(
      safeEvents,
      selectedPresetId,
      null,
      null,
      explicitBucketSizeMs,
    )
  }, [safeEvents, selectedPresetId, explicitBucketSizeMs])

  const windowEvents = useMemo(
    () => histogramModel.filteredEvents || [],
    [histogramModel.filteredEvents],
  )

  const buckets = useMemo(
    () => histogramModel.buckets || [],
    [histogramModel.buckets],
  )

  // Alerts -> Date timestamp for filterEventsByRange
  const normalizedAlerts = useMemo(() => {
    const toDate = (v) => {
      if (v == null) return null

      if (v instanceof Date) return Number.isNaN(v.getTime()) ? null : v

      if (typeof v === 'number' && Number.isFinite(v)) {
        // convert to ms
        const ms = v < 1e12 ? v * 1000 : v
        const d = new Date(ms)
        return Number.isNaN(d.getTime()) ? null : d
      }

      // numeric string
      if (typeof v === 'string') {
        const trimmed = v.trim()
        if (!trimmed) return null

        // "173387..." style numeric string
        if (/^\d+$/.test(trimmed)) {
          const num = Number(trimmed)
          const ms = num < 1e12 ? num * 1000 : num
          const d = new Date(ms)
          return Number.isNaN(d.getTime()) ? null : d
        }

        // ISO string
        const d = new Date(trimmed)
        return Number.isNaN(d.getTime()) ? null : d
      }

      return null
    }

    return (safeAlerts || []).map((a) => {
      const ts =
        toDate(a.timestamp) ||
        toDate(a.time) ||
        toDate(a.ts) ||
        toDate(a.createdAt) ||
        toDate(a.detectedAt) ||
        toDate(a.event?.timestamp) ||
        toDate(a.event?.time)

      return { ...a, timestamp: ts }
    })
  }, [safeAlerts])

  const windowAlerts = useMemo(() => {
    return filterEventsByRange(normalizedAlerts, windowRange.from, windowRange.to)
  }, [normalizedAlerts, windowRange.from, windowRange.to])

  // Basic stats for current window
  const stats = useMemo(() => {
    if (!windowEvents.length) {
      return {
        totalEvents: 0,
        uniqueIps: 0,
        uniqueUsers: 0,
        successCount: 0,
        failCount: 0,
        failRate: null,
      }
    }

    const ips = new Set()
    const users = new Set()
    let success = 0
    let fail = 0

    windowEvents.forEach((e) => {
      if (e.sourceIp) ips.add(e.sourceIp)
      if (e.username) users.add(e.username)
      if (e.outcome === 'success') success += 1
      else if (e.outcome === 'fail') fail += 1
    })

    const totalAuth = success + fail
    const failRate =
      totalAuth > 0 ? Math.round((fail / totalAuth) * 100) : null

    return {
      totalEvents: windowEvents.length,
      uniqueIps: ips.size,
      uniqueUsers: users.size,
      successCount: success,
      failCount: fail,
      failRate,
    }
  }, [windowEvents])

  const highestSeverity = useMemo(() => {
    if (!windowAlerts.length) return null
    if (windowAlerts.some((a) => a.severity === 'high')) return 'high'
    if (windowAlerts.some((a) => a.severity === 'medium')) return 'medium'
    return 'low'
  }, [windowAlerts])

  const datasetSummary = useMemo(() => {
    if (!stats.totalEvents) return ''
    const parts = [`${stats.totalEvents} events`]
    if (stats.uniqueIps) parts.push(`${stats.uniqueIps} IPs`)
    if (stats.uniqueUsers) parts.push(`${stats.uniqueUsers} users`)
    if (stats.successCount + stats.failCount > 0) {
      parts.push(
        `${stats.successCount} success / ${stats.failCount} fail`,
      )
    }
    if (windowAlerts.length) {
      parts.push(
        `${windowAlerts.length} alerts${
          highestSeverity ? ` (max: ${highestSeverity})` : ''
        }`,
      )
    }
    return parts.join(' • ')
  }, [stats, windowAlerts, highestSeverity])

  // Time window summary
  const timeWindowSummary = useMemo(() => {
    if (!histogramModel.from || !histogramModel.to) return ''

    const preset =
      TIME_PRESETS.find((p) => p.id === selectedPresetId) || TIME_PRESETS[0]

    const fromStr = formatLocalDateTime(histogramModel.from)
    const toStr = formatLocalDateTime(histogramModel.to)

    return `${preset.label} • ${fromStr} → ${toStr}`
  }, [histogramModel.from, histogramModel.to, selectedPresetId])

  const baseContextLabel = useMemo(
    () =>
      timeWindowSummary
        ? `Time window: ${timeWindowSummary}`
        : '',
    [timeWindowSummary],
  )

  const bucketContextLabel = useMemo(
    () =>
      timeWindowSummary
        ? `Time window: ${timeWindowSummary}${
            histogramModel.bucketSizeMs
              ? ` • Bucket: ${formatBucketSizeLabel(
                  histogramModel.bucketSizeMs,
                )}`
              : ''
          }`
        : '',
    [timeWindowSummary, histogramModel.bucketSizeMs],
  )

  // Derived series from buckets
  const authOverTime = useMemo(() => {
    if (!buckets.length) {
      return { labels: [], success: [], fail: [] }
    }

    const labels = buckets.map((b) =>
      formatBucketLabel(b.bucketStart, histogramModel.unit, histogramModel.from, histogramModel.to),
    )
    const success = buckets.map((b) => b.success)
    const fail = buckets.map((b) => b.fail)

    return { labels, success, fail }
  }, [buckets, histogramModel.unit, histogramModel.from, histogramModel.to])

  const timeHistogram = useMemo(() => {
    if (!buckets.length) return { labels: [], counts: [] }

    const labels = buckets.map((b) =>
      formatBucketLabel(b.bucketStart, histogramModel.unit, histogramModel.from, histogramModel.to),
    )
    const counts = buckets.map((b) => b.total)

    return { labels, counts }
  }, [buckets, histogramModel.unit, histogramModel.from, histogramModel.to])

  const alertsOverTime = useMemo(() => {
    const bucketsLocal = histogramModel.buckets || []
    if (!bucketsLocal.length || !windowAlerts.length) {
      return { labels: [], counts: [] }
    }

    const from = histogramModel.from
    const bucketMs = histogramModel.bucketSizeMs

    if (!(from instanceof Date) || !bucketMs || !Number.isFinite(bucketMs)) {
      return { labels: [], counts: [] }
    }

    const counts = new Array(bucketsLocal.length).fill(0)

    for (const a of windowAlerts) {
      const ts = a?.timestamp instanceof Date ? a.timestamp : null
      if (!ts) continue
      const idx = Math.floor((ts.getTime() - from.getTime()) / bucketMs)
      if (idx >= 0 && idx < counts.length) counts[idx] += 1
    }

    const labels = bucketsLocal.map((b) =>
      formatBucketLabel(b.bucketStart, histogramModel.unit, histogramModel.from, histogramModel.to),
    )

    return { labels, counts }
  }, [histogramModel, windowAlerts])

  // Top noisy IPs
  const topIps = useMemo(() => {
    if (!windowEvents.length) return []
    const ipCounts = new Map()
    windowEvents.forEach((e) => {
      if (!e.sourceIp) return
      ipCounts.set(e.sourceIp, (ipCounts.get(e.sourceIp) || 0) + 1)
    })
    return Array.from(ipCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
  }, [windowEvents])

  // Top usernames (all events)
  const topUsers = useMemo(() => {
    if (!windowEvents.length) return []
    const userCounts = new Map()
    windowEvents.forEach((e) => {
      if (!e.username) return
      userCounts.set(
        e.username,
        (userCounts.get(e.username) || 0) + 1,
      )
    })
    return Array.from(userCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
  }, [windowEvents])

  const topDestinations = useMemo(() => {
    if (!windowEvents.length) return []

    const counts = new Map()

    windowEvents.forEach((e) => {
      const dest =
        e.destIp ||
        e.destinationIp ||
        e.dstIp ||
        e.dest ||
        e.destination ||
        e.host ||
        e.hostname ||
        e.destHost ||
        null

      if (!dest) return
      counts.set(dest, (counts.get(dest) || 0) + 1)
    })

    return Array.from(counts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
  }, [windowEvents])

  // Auth failures by username
  const authFailuresByUser = useMemo(() => {
    if (!windowEvents.length) return []
    const failCounts = new Map()
    windowEvents.forEach((e) => {
      if (!e.username) return
      if (e.outcome !== 'fail') return
      failCounts.set(
        e.username,
        (failCounts.get(e.username) || 0) + 1,
      )
    })
    return Array.from(failCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
  }, [windowEvents])

  // Event types breakdown
  const eventTypeBreakdown = useMemo(() => {
    if (!windowEvents.length) return []
    const counts = new Map()
    windowEvents.forEach((e) => {
      const key = e.eventType || 'event'
      counts.set(key, (counts.get(key) || 0) + 1)
    })
    return Array.from(counts.entries()).sort((a, b) => b[1] - a[1])
  }, [windowEvents])

  // Alerts by severity
  const alertsBySeverity = useMemo(() => {
    const counts = { high: 0, medium: 0, low: 0 }
    windowAlerts.forEach((a) => {
      if (a.severity === 'high') counts.high += 1
      else if (a.severity === 'medium') counts.medium += 1
      else counts.low += 1
    })
    return counts
  }, [windowAlerts])

  // Alerts by category (rule grouping)
  const alertsByCategoryDetails = useMemo(() => {
    if (!windowAlerts.length) return []

    const perCategoryCount = new Map()
    const perCategoryRules = new Map()

    windowAlerts.forEach((a) => {
      const type = a.type || 'unknown'
      const category = getRuleCategoryLabel(type)

      perCategoryCount.set(
        category,
        (perCategoryCount.get(category) || 0) + 1,
      )

      if (!perCategoryRules.has(category)) {
        perCategoryRules.set(category, new Map())
      }
      const ruleMap = perCategoryRules.get(category)
      ruleMap.set(type, (ruleMap.get(type) || 0) + 1)
    })

    return Array.from(perCategoryCount.entries())
      .map(([category, count]) => ({
        category,
        count,
        rules: Array.from(
          (perCategoryRules.get(category) || new Map()).entries(),
        ).sort((a, b) => b[1] - a[1]),
      }))
      .sort((a, b) => b.count - a.count)
  }, [windowAlerts])

  const topAlertEntities = useMemo(() => {
    if (!windowAlerts.length) return []

    const counts = new Map()

    const pickEntity = (a) => {
      if (!a) return null

      // IP-like (common variants)
      const ip =
        a.sourceIp ||
        a.srcIp ||
        a.ip ||
        a.src?.ip ||
        a.source?.ip ||
        a.entity?.ip ||
        a.entity?.sourceIp ||
        (a.entity?.kind === 'ip' ? a.entity?.value : null) ||
        (a.entity?.type === 'ip' ? a.entity?.value : null)

      if (ip) return String(ip)

      // User-like (common variants)
      const user =
        a.username ||
        a.user ||
        a.principal?.user ||
        a.actor?.user ||
        a.entity?.user ||
        a.entity?.username ||
        (a.entity?.kind === 'user' ? a.entity?.value : null) ||
        (a.entity?.type === 'user' ? a.entity?.value : null) ||
        (a.entity?.type === 'username' ? a.entity?.value : null)

      if (user) return String(user)

      // Generic entity/value
      const generic =
        a.entity?.value ||
        a.value ||
        a.entity?.id ||
        a.subject ||
        a.target ||
        null

      if (generic) return String(generic)

      // Fallback: parse common entity hints from description/title
      const text = `${a.title || ''} ${a.description || ''}`

      // username "alice"
      const mUser = text.match(/username\s+"([^"]+)"/i)
      if (mUser?.[1]) return mUser[1]

      // user "alice" (more generic)
      const mUser2 = text.match(/\buser\s+"([^"]+)"/i)
      if (mUser2?.[1]) return mUser2[1]

      // IP address (basic)
      const mIp = text.match(/\b(\d{1,3}(?:\.\d{1,3}){3})\b/)
      if (mIp?.[1]) return mIp[1]

      return null
    }

    for (const a of windowAlerts) {
      const k = pickEntity(a)
      if (!k) continue
      counts.set(k, (counts.get(k) || 0) + 1)
    }

    return Array.from(counts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
  }, [windowAlerts])

  // Per-chart summary strings
  const hasAuth = stats.successCount + stats.failCount > 0
  const failRateSuffix =
    stats.failRate !== null ? ` (${stats.failRate}% fail)` : ''

  const authTimelineSummary = hasAuth
    ? `Auth timeline: ${stats.successCount} success / ${stats.failCount} fail${failRateSuffix}`
    : ''

  const authDistributionSummary = hasAuth
    ? `Auth distribution: ${stats.successCount} success / ${stats.failCount} fail${failRateSuffix}`
    : ''

  const topIpsSummary = topIps.length
    ? `Top IPs: ${topIps
        .map(([ip, count]) => `${ip} (${count})`)
        .join(', ')}`
    : ''

  const topUsersSummary = topUsers.length
    ? `Top users: ${topUsers
        .map(([u, count]) => `${u} (${count})`)
        .join(', ')}`
    : ''

  const authFailuresSummary = authFailuresByUser.length
    ? `Auth failures by user: ${authFailuresByUser
        .map(([u, count]) => `${u} (${count})`)
        .join(', ')}`
    : ''

  const eventTypesSummary = eventTypeBreakdown.length
    ? `Event types: ${eventTypeBreakdown
        .map(([t, count]) => `${t} (${count})`)
        .join(', ')}`
    : ''

  const alertsSummary = windowAlerts.length
    ? `Alerts: ${alertsBySeverity.high} high • ${alertsBySeverity.medium} medium • ${alertsBySeverity.low} low`
    : ''

  const alertsByTypeSummary = alertsByCategoryDetails.length
    ? `Alerts by category: ${alertsByCategoryDetails
        .map((cat) => `${cat.category} (${cat.count})`)
        .join(', ')}`
    : ''

  const timeHistogramSummary =
    timeHistogram.labels.length > 0
      ? histogramModel.bucketSizeMs
        ? `Event density histogram • Bucket: ${formatBucketSizeLabel(histogramModel.bucketSizeMs)}`
        : 'Event density histogram • Bucket: auto'
      : ''

  const alertsOverTimeSummary =
    alertsOverTime.labels.length > 0
      ? `Alerts over time: ${windowAlerts.length} total`
      : ''

  const topDestinationsSummary = topDestinations.length
    ? `Top destinations: ${topDestinations
        .map(([d, c]) => `${d} (${c})`)
        .join(', ')}`
    : ''

  const topAlertEntitiesSummary = topAlertEntities.length
    ? `Top alerting entities: ${topAlertEntities
        .map(([k, c]) => `${k} (${c})`)
        .join(', ')}`
    : ''

  // Chart refs
  const authChartRef = useRef(null)
  const authPieRef = useRef(null)
  const timeHistChartRef = useRef(null)
  const ipChartRef = useRef(null)
  const userChartRef = useRef(null)
  const failUserChartRef = useRef(null)
  const typeChartRef = useRef(null)
  const alertsChartRef = useRef(null)
  const alertsTypeChartRef = useRef(null)
  const alertsOverTimeRef = useRef(null)
  const destChartRef = useRef(null)
  const topAlertEntitiesRef = useRef(null)

  // Chart data + options
  const authChartData = {
    labels: authOverTime.labels,
    datasets: [
      {
        label: 'Successful auth',
        data: authOverTime.success,
        borderWidth: 2,
        tension: 0.3,
        borderColor: '#22c55e',
        backgroundColor: 'rgba(34,197,94,0.18)',
        pointRadius: 3,
        pointBackgroundColor: '#22c55e',
        pointBorderWidth: 0,
      },
      {
        label: 'Failed auth',
        data: authOverTime.fail,
        borderWidth: 2,
        tension: 0.3,
        borderColor: '#fb7185',
        backgroundColor: 'rgba(251,113,133,0.18)',
        pointRadius: 3,
        pointBackgroundColor: '#fb7185',
        pointBorderWidth: 0,
      },
    ],
  }

  const maxAuthBucket = Math.max(
    1,
    ...(authOverTime.success || []),
    ...(authOverTime.fail || []),
  )

  const authChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        labels: {
          color: '#e5e7eb',
          font: { size: 9 },
        },
      },
      tooltip: {
        mode: 'index',
        intersect: false,
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#cbd5f5',
          maxRotation: 0,
          font: { size: 9 },
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
      },
      y: {
        ticks: {
          color: '#cbd5f5',
          maxTicksLimit: 8,
          precision: 0,
          font: { size: 9 },
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
        suggestedMax: maxAuthBucket,
      },
    },
  }

  const timeHistChartData = {
    labels: timeHistogram.labels,
    datasets: [
      {
        label: 'Events per bucket',
        data: timeHistogram.counts,
        backgroundColor: '#0ea5e9',
        borderColor: '#0284c7',
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const timeHistChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        display: false,
      },
      tooltip: {
        mode: 'nearest',
        intersect: true,
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          maxRotation: 0,
        },
        grid: {
          color: 'rgba(148,163,184,0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148,163,184,0.45)',
        },
      },
      y: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          maxTicksLimit: 8,
          precision: 0,
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
    },
  }

  const authPieData = {
    labels: ['Success', 'Fail'],
    datasets: [
      {
        data: [stats.successCount || 0, stats.failCount || 0],
        backgroundColor: ['#22c55e', '#fb7185'],
        borderColor: '#020617',
        borderWidth: 2,
      },
    ],
  }

  const authPieOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        labels: {
          color: '#e5e7eb',
          font: { size: 9 },
        },
      },
    },
  }

  const ipChartData = {
    labels: topIps.map(([ip]) => ip),
    datasets: [
      {
        label: 'Events',
        data: topIps.map(([, count]) => count),
        backgroundColor: COLOR_ENTITY_FILL,
        borderColor: COLOR_ENTITY_BORDER,
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const ipChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    indexAxis: 'y',
    plugins: {
      legend: {
        display: false,
      },
      tooltip: {
        mode: 'nearest',
        intersect: true,
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          maxTicksLimit: 8,
          precision: 0,
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
      y: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
        },
        grid: {
          display: false,
        },
      },
    },
  }

  const userChartData = {
    labels: topUsers.map(([u]) => u),
    datasets: [
      {
        label: 'Events',
        data: topUsers.map(([, count]) => count),
        backgroundColor: COLOR_ENTITY_FILL,
        borderColor: COLOR_ENTITY_BORDER,
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const userChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    indexAxis: 'y',
    plugins: {
      legend: {
        display: false,
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          maxTicksLimit: 8,
          precision: 0,
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
      y: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          autoSkip: false,
        },
        grid: {
          display: false,
        },
      },
    },
  }

  const authFailuresChartData = {
    labels: authFailuresByUser.map(([u]) => u),
    datasets: [
      {
        label: 'Failed auth events',
        data: authFailuresByUser.map(([, count]) => count),
        backgroundColor: COLOR_ALERT_FILL,
        borderColor: COLOR_ALERT_BORDER,
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const authFailuresChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    indexAxis: 'y',
    plugins: {
      legend: {
        display: false,
      },
      tooltip: {
        mode: 'nearest',
        intersect: true,
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          maxTicksLimit: 8,
          precision: 0,
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
      y: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
        },
        grid: {
          display: false,
        },
      },
    },
  }

  const typeChartData = {
    labels: eventTypeBreakdown.map(([type]) => type),
    datasets: [
      {
        data: eventTypeBreakdown.map(([, count]) => count),
        backgroundColor: eventTypeBreakdown.map(([t]) =>
          colorFromLabel(t, { s: 70, l: 55 }),
        ),
        borderColor: '#020617',
        borderWidth: 2,
      },
    ],
  }

  const typeChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        labels: {
          color: '#e5e7eb',
          font: { size: 9 },
        },
      },
      tooltip: {
        callbacks: {
          label: (ctx) => {
            const label = ctx.label || 'event'
            const value = ctx.parsed
            return `${label}: ${value}`
          },
        },
      },
    },
  }

  const alertsChartData = {
    labels: ['High', 'Medium', 'Low'],
    datasets: [
      {
        label: 'Alerts',
        data: [
          alertsBySeverity.high,
          alertsBySeverity.medium,
          alertsBySeverity.low,
        ],
        backgroundColor: ['#fb7185', '#facc15', '#22c55e'],
        borderColor: ['#f97373', '#eab308', '#16a34a'],
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const alertsChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        display: false,
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
      },
      y: {
        ticks: {
          color: '#94a3b8',
          font: { size: 9 },
          maxTicksLimit: 8,
          precision: 0,
        },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
    },
  }

  const paletteFill = useMemo(
    () => [
      '#22c55e',
      '#0ea5e9',
      '#a855f7',
      '#f97316',
      '#fb7185',
      '#facc15',
    ],
    [],
  )

  const paletteBorder = useMemo(
    () => [
      '#16a34a',
      '#0284c7',
      '#7c3aed',
      '#ea580c',
      '#f43f5e',
      '#eab308',
    ],
    [],
  )

  const alertsTypeChartData = useMemo(() => {
    if (!alertsByCategoryDetails.length) {
      return {
        labels: [],
        datasets: [
          {
            label: 'Alerts',
            data: [],
            backgroundColor: paletteFill[0],
            borderColor: paletteBorder[0],
            borderRadius: 10,
            borderWidth: 1,
          },
        ],
      }
    }

    const labels = alertsByCategoryDetails.map((c) => c.category)
    const data = alertsByCategoryDetails.map((c) => c.count)

    const backgroundColor = labels.map(
      (_, idx) => paletteFill[idx % paletteFill.length],
    )
    const borderColor = labels.map(
      (_, idx) => paletteBorder[idx % paletteBorder.length],
    )

    return {
      labels,
      datasets: [
        {
          label: 'Alerts',
          data,
          backgroundColor,
          borderColor,
          borderRadius: 10,
          borderWidth: 1,
        },
      ],
    }
  }, [alertsByCategoryDetails, paletteFill, paletteBorder])

  const alertsTypeChartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        display: false,
      },
      tooltip: {
        mode: 'nearest',
        intersect: true,
        callbacks: {
          title: (items) => {
            const idx = items[0].dataIndex
            const details = alertsByCategoryDetails[idx]
            return details ? details.category : ''
          },
          label: (item) => {
            const idx = item.dataIndex
            const details = alertsByCategoryDetails[idx]
            if (!details) return ''

            const lines = []
            lines.push(`${details.category}: ${details.count} alerts`)
            details.rules.forEach(([ruleType, ruleCount]) => {
              lines.push(`• ${ruleType} (${ruleCount})`)
            })

            return lines
          },
        },
      },
    },
    scales: {
      x: {
        ticks: {
          color: '#e5e7eb',
          font: { size: 9 },
          autoSkip: false,
          maxRotation: 30,
          minRotation: 0,
        },
        grid: {
          display: false,
        },
      },
      y: {
        beginAtZero: true,
        ticks: {
          maxTicksLimit: 8,
          color: '#9ca3af',
        },
        grid: {
          color: '#1f2937',
        },
      },
    },
  }

  const alertsOverTimeData = {
    labels: alertsOverTime.labels,
    datasets: [
      {
        label: 'Alerts per bucket',
        data: alertsOverTime.counts,
        backgroundColor: '#facc15',
        borderColor: '#eab308',
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const alertsOverTimeOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { display: false },
      tooltip: { mode: 'nearest', intersect: true },
    },
    scales: {
      x: {
        ticks: { color: '#94a3b8', font: { size: 9 }, maxRotation: 0 },
        grid: {
          color: 'rgba(148,163,184,0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148,163,184,0.45)',
        },
      },
      y: {
        ticks: { color: '#94a3b8', font: { size: 9 }, maxTicksLimit: 8, precision: 0 },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
    },
  }

  const destChartData = {
  labels: topDestinations.map(([d]) => d),
  datasets: [
    {
      label: 'Events',
      data: topDestinations.map(([, c]) => c),
      backgroundColor: COLOR_ENTITY_FILL,
      borderColor: COLOR_ENTITY_BORDER,
      borderWidth: 1,
      borderRadius: 4,
    },
  ],
}

  const destChartOptions = {
    ...ipChartOptions,
    // If skipping force show all
    scales: {
      ...ipChartOptions.scales,
      y: {
        ...ipChartOptions.scales.y,
        ticks: { ...ipChartOptions.scales.y.ticks, autoSkip: false },
      },
    },
  }

  const topAlertEntitiesData = {
    labels: topAlertEntities.map(([k]) => k),
    datasets: [
      {
        label: 'Alerts',
        data: topAlertEntities.map(([, c]) => c),
        backgroundColor: COLOR_ALERT_FILL,
        borderColor: COLOR_ALERT_BORDER,
        borderWidth: 1,
        borderRadius: 4,
      },
    ],
  }

  const topAlertEntitiesOptions = {
    responsive: true,
    maintainAspectRatio: false,
    indexAxis: 'y',
    plugins: { legend: { display: false } },
    scales: {
      x: {
        ticks: { color: '#94a3b8', font: { size: 9 }, maxTicksLimit: 8, precision: 0 },
        grid: {
          color: 'rgba(148, 163, 184, 0.28)',
          lineWidth: 1,
          borderColor: 'rgba(148, 163, 184, 0.45)',
        },
        beginAtZero: true,
      },
      y: {
        ticks: { color: '#94a3b8', font: { size: 9 }, autoSkip: false },
        grid: { display: false },
      },
    },
  }

  // Helper
  function roundRectPath(ctx, x, y, w, h, r) {
    const radius = Math.min(r, w / 2, h / 2)

    if (typeof ctx.roundRect === 'function') {
      ctx.beginPath()
      ctx.roundRect(x, y, w, h, radius)
      return
    }

    // manual rounded-rect path fallback
    ctx.beginPath()
    ctx.moveTo(x + radius, y)
    ctx.arcTo(x + w, y, x + w, y + h, radius)
    ctx.arcTo(x + w, y + h, x, y + h, radius)
    ctx.arcTo(x, y + h, x, y, radius)
    ctx.arcTo(x, y, x + w, y, radius)
    ctx.closePath()
  }

  // Export full overview
  function drawStatTile(ctx, x, y, w, h, label, value, extraLine) {
    ctx.fillStyle = '#0f172a'
    roundRectPath(ctx, x, y, w, h, 12)
    ctx.fill()

    ctx.fillStyle = '#94a3b8'
    ctx.font = '11px system-ui, sans-serif'
    ctx.textAlign = 'left'
    ctx.fillText(label, x + 12, y + 22)

    ctx.fillStyle = '#f8fafc'
    ctx.font = '20px system-ui, sans-serif'
    ctx.fillText(value, x + 12, y + 48)

    if (extraLine) {
      ctx.fillStyle = '#fda4af'
      ctx.font = '11px system-ui, sans-serif'
      ctx.fillText(extraLine, x + 12, y + 68)
    }
  }

  const handleExportOverview = async () => {
    try {
      authChartRef.current?.update()
      authPieRef.current?.update()
      timeHistChartRef.current?.update()
      ipChartRef.current?.update()
      userChartRef.current?.update()
      failUserChartRef.current?.update()
      typeChartRef.current?.update()
      alertsChartRef.current?.update()
      alertsTypeChartRef.current?.update()
      alertsOverTimeRef.current?.update()
      destChartRef.current?.update()
      topAlertEntitiesRef.current?.update()

      await new Promise((r) => setTimeout(r, 50))

      const blocksRaw = [
        {
          ref: timeHistChartRef.current,
          title: 'Event density histogram',
          summary: timeHistogramSummary,
          wide: true,
        },

        // Match UI
        {
          ref: alertsOverTimeRef.current,
          title: 'Alerts over time',
          summary: alertsOverTimeSummary,
        },
        {
          ref: alertsChartRef.current,
          title: 'Alerts by severity',
          summary: alertsSummary,
        },

        // Next row
        {
          ref: authChartRef.current,
          title: 'Auth outcomes over time',
          summary: authTimelineSummary,
        },
        {
          ref: authPieRef.current,
          title: 'Auth distribution',
          summary: authDistributionSummary,
        },

        // Next row
        {
          ref: ipChartRef.current,
          title: 'Top noisy IPs',
          summary: topIpsSummary,
        },
        {
          ref: destChartRef.current,
          title: 'Top destination IPs / hosts',
          summary: topDestinationsSummary,
        },

        // Next row
        {
          ref: typeChartRef.current,
          title: 'Event types breakdown',
          summary: eventTypesSummary,
        },
        {
          ref: alertsTypeChartRef.current,
          title: 'Alerts by rule type',
          summary: alertsByTypeSummary,
        },

        // Next row
        {
          ref: userChartRef.current,
          title: 'Top usernames',
          summary: topUsersSummary,
        },
        {
          ref: failUserChartRef.current,
          title: 'Auth failures by username',
          summary: authFailuresSummary,
        },

        // Last
        {
          ref: topAlertEntitiesRef.current,
          title: 'Top alerting entities',
          summary: topAlertEntitiesSummary,
          wide: true,
        },
      ]

      const chartBlocks = blocksRaw
        .filter((b) => b.ref)
        .map((b) => {
          const chartRef = b.ref
          const canvas = chartRef.canvas || chartRef.ctx?.canvas

          let naturalW = 0
          let naturalH = 0

          if (canvas) {
            const rect = canvas.getBoundingClientRect()
            naturalW = rect.width || canvas.width || 0
            naturalH = rect.height || canvas.height || 0
          }

          return {
            ...b,
            imgSrc: chartRef.toBase64Image(),
            naturalW,
            naturalH,
          }
        })

      if (!chartBlocks.length) return

      const padding = 32

      const statTileW = 260
      const statTileH = 90
      const statTileGap = 20
      const statsRowHeight = statTileH + 20

      const chartW = 880
      const chartH = 420
      const columns = 2

      const positionedBlocks = []
      let row = 0
      let col = 0

      chartBlocks.forEach((block) => {
        if (block.wide) {
          positionedBlocks.push({ ...block, row, col: 0 })
          row += 1
          col = 0
        } else {
          positionedBlocks.push({ ...block, row, col })
          if (col === columns - 1) {
            col = 0
            row += 1
          } else {
            col += 1
          }
        }
      }
    )

      const totalRows = row
      const footerLineHeight = 14
      const footerTopPad = 10
      const footerBottomPad = 12
      const footerMarketingGap = 18

      const measureCanvas = document.createElement('canvas')
      const mctx = measureCanvas.getContext('2d')
      if (!mctx) return
      mctx.font = 'italic 13px system-ui, sans-serif'

      const footerMaxW = (padding * 2 + chartW * columns + padding * (columns - 1)) - padding * 2
      const footerLines = splitTextLines(mctx, datasetSummary || '', footerMaxW)

      const datasetBlockH = footerLines.length > 0
        ? footerLines.length * footerLineHeight
        : 0

      const footerHeight =
        footerTopPad +
        datasetBlockH +
        (datasetBlockH ? footerMarketingGap : 0) +
        16 + 
        footerBottomPad

      const timeContextLine = timeWindowSummary
        ? `Time window: ${timeWindowSummary}`
        : ''
      const bucketContextLine =
        histogramModel.bucketSizeMs != null
          ? `Bucket: ${formatBucketSizeLabel(
              histogramModel.bucketSizeMs,
            )}`
          : ''
      const hasTimeContext =
        timeContextLine.length > 0 || bucketContextLine.length > 0

      const extraTopGap = hasTimeContext ? 52 : 20

      const exportCanvas = document.createElement('canvas')
      exportCanvas.width =
        padding * 2 + chartW * columns + padding * (columns - 1)
      exportCanvas.height =
        padding +
        extraTopGap +
        statsRowHeight +
        padding +
        chartH * totalRows +
        padding * (totalRows - 1) +
        footerHeight

      const ctx = exportCanvas.getContext('2d')
      if (!ctx) return

      ctx.fillStyle = '#020617'
      ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height)

      const exportedAt = new Date().toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
      })

      const datasetLabel =
        stats.totalEvents > 0
          ? `${stats.totalEvents} events`
          : 'No events loaded'

      ctx.fillStyle = '#e5e7eb'
      ctx.font = 'bold 20px system-ui, sans-serif'
      ctx.textAlign = 'left'
      ctx.fillText('Mini SIEM Overview Export', padding, padding)

      ctx.textAlign = 'right'
      ctx.font = '11px system-ui, sans-serif'
      ctx.fillStyle = '#94a3b8'
      ctx.fillText(
        `${exportedAt} • ${datasetLabel}`,
        exportCanvas.width - padding,
        padding + 4,
      )

      // Time window + bucket context
      let headerY = padding + 22
      ctx.textAlign = 'left'
      ctx.font = '11px system-ui, sans-serif'
      ctx.fillStyle = '#9ca3af'
      if (timeContextLine) {
        ctx.fillText(timeContextLine, padding, headerY)
        headerY += 14
      }
      if (bucketContextLine) {
        ctx.fillText(bucketContextLine, padding, headerY)
      }

      const statX0 = padding
      const statY0 = padding + extraTopGap

      drawStatTile(
        ctx,
        statX0,
        statY0,
        statTileW,
        statTileH,
        'Events (current window)',
        stats.totalEvents,
      )

      drawStatTile(
        ctx,
        statX0 + statTileW + statTileGap,
        statY0,
        statTileW,
        statTileH,
        'Alerts generated (current window)',
        windowAlerts.length,
        highestSeverity ? `Highest: ${highestSeverity}` : null,
      )

      drawStatTile(
        ctx,
        statX0 + (statTileW + statTileGap) * 2,
        statY0,
        statTileW,
        statTileH,
        'Unique IPs (current window)',
        stats.uniqueIps,
      )

      drawStatTile(
        ctx,
        statX0 + (statTileW + statTileGap) * 3,
        statY0,
        statTileW,
        statTileH,
        'Unique users (current window)',
        stats.uniqueUsers,
      )

      const chartOffsetY = statY0 + statTileH + 40

      const titleHeight = 20
      const summaryHeight = 18
      const chartInnerTopOffset = titleHeight + 6
      const chartInnerBottomOffset = summaryHeight + 6
      const wideInnerW =
        chartW * columns + padding * (columns - 1)

      for (const block of positionedBlocks) {
        const blockX = block.wide
          ? padding
          : padding + block.col * (chartW + padding)
        const blockY =
          chartOffsetY + block.row * (chartH + padding)

        ctx.textAlign = 'left'
        ctx.textBaseline = 'top'
        ctx.fillStyle = '#e5e7eb'
        ctx.font = '12px system-ui, sans-serif'
        ctx.fillText(block.title, blockX, blockY)

        const innerX = blockX
        const innerY = blockY + chartInnerTopOffset
        const innerW = block.wide ? wideInnerW : chartW
        const innerH =
          chartH - chartInnerTopOffset - chartInnerBottomOffset

        const img = new Image()
        img.src = block.imgSrc

        await new Promise((resolve) => {
          img.onload = () => {
            let natW = block.naturalW || innerW
            let natH = block.naturalH || innerH
            let ratio = natW / natH || 1

            let drawW = innerW
            let drawH = drawW / ratio
            if (drawH > innerH) {
              drawH = innerH
              drawW = drawH * ratio
            }

            const offsetX = innerX + (innerW - drawW) / 2
            const offsetY = innerY + (innerH - drawH) / 2

            ctx.drawImage(img, offsetX, offsetY, drawW, drawH)
            resolve()
          }
        })

        if (block.summary) {
          ctx.textAlign = 'center'
          ctx.textBaseline = 'bottom'
          ctx.fillStyle = '#6ee7b7'
          ctx.font = 'italic 11px system-ui, sans-serif'

          const centerX = blockX + (block.wide ? wideInnerW : chartW) / 2
          const maxW = (block.wide ? wideInnerW : chartW) - 24

          wrapText(
            ctx,
            block.summary,
            centerX,
            blockY + chartH - 26,
            maxW,
            12,
            2,
            'center',
          )
        }
      }

      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'

      ctx.fillStyle = '#6ee7b7'
      ctx.font = 'italic 13px system-ui, sans-serif'
      wrapText(
        ctx,
        datasetSummary || '',
        exportCanvas.width / 2,
        exportCanvas.height - footerHeight + 10,
        exportCanvas.width - padding * 2,
        14,
        2,
        'center',
      )

      ctx.fillStyle = '#e5e7eb'
      ctx.font = 'italic 12px system-ui, sans-serif'
      ctx.fillText(
        'Generated by Security Webtools',
        exportCanvas.width / 2,
        exportCanvas.height - footerHeight + 45,
      )

      exportCanvas.toBlob((blob) => {
        if (!blob) return
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = 'mini-siem-overview.png'
        document.body.appendChild(a)
        a.click()
        a.remove()
        URL.revokeObjectURL(url)
      })
    } catch (err) {
      console.error('Failed to export overview:', err)
    }
  }

  // Render
  const presetOptions = TIME_PRESETS

  return (
    <div className="mt-4 space-y-4">
      <div className="mb-1 flex flex-col gap-2 md:flex-row md:items-center md:justify-between text-[0.7rem]">
        <div className="space-y-0.5">
          <span className="text-slate-400">
            Overview is computed locally from the normalized events.
          </span>
          {timeWindowSummary && (
            <div className="text-slate-500">
              Time window:{' '}
              <span className="text-slate-300">
                {timeWindowSummary}
              </span>
            </div>
          )}
        </div>
        <div className="flex flex-wrap items-center gap-2">
          <label className="flex items-center gap-1 text-slate-400">
            Window
            <select
              value={selectedPresetId}
              onChange={(e) => setSelectedPresetId(e.target.value)}
              className="rounded-full border border-slate-700 bg-slate-950/80 px-2 py-0.5 text-[0.7rem] text-slate-100 focus:outline-none focus:ring-1 focus:ring-emerald-500/60"
            >
              {presetOptions.map((p) => (
                <option key={p.id} value={p.id}>
                  {p.label}
                </option>
              ))}
            </select>
          </label>
          <button
            type="button"
            onClick={handleExportOverview}
            className="rounded-full border border-slate-700 bg-slate-900/80 px-3 py-1 text-[0.7rem] text-slate-100 hover:border-emerald-500/70 hover:text-emerald-200"
          >
            Export overview (PNG)
          </button>
        </div>
      </div>

      <div ref={overviewRef} className="space-y-4">
        {/* Stat tiles */}
        <div className="grid gap-3 md:grid-cols-4">
          <div className="rounded-2xl border border-slate-800 bg-slate-950/70 p-3">
            <div className="text-[0.7rem] text-slate-400">
              Events (current window)
            </div>
            <div className="mt-1 text-xl font-semibold text-slate-50">
              {stats.totalEvents}
            </div>
          </div>
          <div className="rounded-2xl border border-slate-800 bg-slate-950/70 p-3">
            <div className="text-[0.7rem] text-slate-400">
              Alerts generated (current window)
            </div>
            <div className="mt-1 text-xl font-semibold text-slate-50">
              {windowAlerts.length}
            </div>
            {highestSeverity && windowAlerts.length > 0 && (
              <div className="mt-1 text-[0.65rem] text-rose-300">
                Highest severity: {highestSeverity}
              </div>
            )}
          </div>
          <div className="rounded-2xl border border-slate-800 bg-slate-950/70 p-3">
            <div className="text-[0.7rem] text-slate-400">
              Unique source IPs (current window)
            </div>
            <div className="mt-1 text-xl font-semibold text-slate-50">
              {stats.uniqueIps}
            </div>
          </div>
          <div className="rounded-2xl border border-slate-800 bg-slate-950/70 p-3">
            <div className="text-[0.7rem] text-slate-400">
              Unique usernames (current window)
            </div>
            <div className="mt-1 text-xl font-semibold text-slate-50">
              {stats.uniqueUsers}
            </div>
          </div>
        </div>

        {/* Charts row 1 - Time bucket histogram (wide) */}
        <div className="grid gap-3">
          <ChartCard
            title="Event density histogram"
            description="Events grouped into time buckets across the loaded window."
            chartRef={timeHistChartRef}
            filename="mini-siem-time-histogram.png"
            footerSummary={timeHistogramSummary}
            contextLabel={bucketContextLabel}
          >
            <div className="mb-2 flex flex-wrap items-center justify-end gap-2">
              <label className="flex items-center gap-1 text-[0.65rem] text-slate-400">
                Bucket size
                <select
                  className="rounded border border-slate-700 bg-slate-900 px-1 py-0.5 text-[0.65rem] text-slate-100"
                  value={effectiveBucketChoice}
                  onChange={(e) => setBucketSizeChoice(e.target.value)}
                >
                  {bucketOptions.map((opt) => (
                    <option key={opt} value={opt}>
                      {BUCKET_LABELS[opt] || opt}
                    </option>
                  ))}
                </select>
              </label>
            </div>

            {timeHistogram.labels.length > 0 ? (
              <div className="h-56">
                <Bar
                  ref={timeHistChartRef}
                  data={timeHistChartData}
                  options={timeHistChartOptions}
                />
              </div>
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                Not enough timestamped events in the selected window to build
                this histogram.
              </div>
            )}
          </ChartCard>
        </div>
        <div className="grid gap-3 md:grid-cols-2">                  
        <ChartCard
          title="Alerts over time"
          description="Generated alerts grouped into time buckets for the selected window."
          chartRef={alertsOverTimeRef}
          filename="mini-siem-alerts-over-time.png"
          footerSummary={alertsOverTimeSummary}
          contextLabel={bucketContextLabel}
        >
          {alertsOverTime.labels.length > 0 ? (
            <Bar
              ref={alertsOverTimeRef}
              data={alertsOverTimeData}
              options={alertsOverTimeOptions}
            />
          ) : (
            <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
              No alerts generated for the current window.
            </div>
          )}
        </ChartCard> 
        <ChartCard
          title="Alerts by severity"
          description="Count of generated alerts per severity level."
          chartRef={alertsChartRef}
          filename="mini-siem-alerts-by-severity.png"
          footerSummary={alertsSummary}
          contextLabel={baseContextLabel}
        >
          {windowAlerts.length > 0 ? (
            <Bar
              ref={alertsChartRef}
              data={alertsChartData}
              options={alertsChartOptions}
            />
          ) : (
            <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
              No alerts generated for the current window.
            </div>
          )}
        </ChartCard>
        </div>

        {/* Charts row 2 */}
        <div className="grid gap-3 md:grid-cols-2">
          <ChartCard
            title="Auth outcomes over time"
            description="Success / failure counts in time buckets for the selected window."
            chartRef={authChartRef}
            filename="mini-siem-auth-over-time.png"
            footerSummary={authTimelineSummary}
            contextLabel={bucketContextLabel}
          >
            {authOverTime.labels.length > 0 ? (
              <Line
                ref={authChartRef}
                data={authChartData}
                options={authChartOptions}
              />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                Not enough timestamped events in the selected window to build
                this chart.
              </div>
            )}
          </ChartCard>

          <ChartCard
            title="Auth distribution"
            description="Global split of successful vs failed authentication outcomes in the current window."
            chartRef={authPieRef}
            filename="mini-siem-auth-distribution.png"
            footerSummary={authDistributionSummary}
            contextLabel={baseContextLabel}
          >
            {stats.successCount + stats.failCount > 0 ? (
              <Doughnut
                ref={authPieRef}
                data={authPieData}
                options={authPieOptions}
              />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No authentication outcomes detected in the selected window.
              </div>
            )}
          </ChartCard>
        </div>

        {/* Charts row 3 */}
        <div className="grid gap-3 md:grid-cols-2">
          <ChartCard
            title="Top noisy IPs"
            description="IPs ranked by number of normalized events in the selected window."
            chartRef={ipChartRef}
            filename="mini-siem-top-ips.png"
            footerSummary={topIpsSummary}
            contextLabel={baseContextLabel}
          >
            {topIps.length > 0 ? (
              <Bar
                ref={ipChartRef}
                data={ipChartData}
                options={ipChartOptions}
              />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No IP information available in the current window.
              </div>
            )}
          </ChartCard>

          <ChartCard
            title="Top destination IPs / hosts"
            description="Destinations ranked by normalized event volume in the selected window."
            chartRef={destChartRef}
            filename="mini-siem-top-destinations.png"
            footerSummary={topDestinationsSummary}
            contextLabel={baseContextLabel}
          >
            {topDestinations.length > 0 ? (
              <Bar ref={destChartRef} data={destChartData} options={destChartOptions} />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No destination/host information available in the current window.
              </div>
            )}
          </ChartCard>

          <ChartCard
            title="Event types breakdown"
            description="Relative volume of normalized event types in the selected window."
            chartRef={typeChartRef}
            filename="mini-siem-event-types.png"
            footerSummary={eventTypesSummary}
            contextLabel={baseContextLabel}
          >
            {eventTypeBreakdown.length > 0 ? (
              <Doughnut
                ref={typeChartRef}
                data={typeChartData}
                options={typeChartOptions}
              />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No events to summarise in the selected window.
              </div>
            )}
          </ChartCard>
          <ChartCard
            title="Alerts by rule type"
            description="Counts of generated alerts grouped by detection rule category."
            chartRef={alertsTypeChartRef}
            filename="mini-siem-alerts-by-type.png"
            footerSummary={alertsByTypeSummary}
            contextLabel={baseContextLabel}
          >
            {alertsByCategoryDetails.length > 0 ? (
              <div className="mx-auto w-full max-w-[640px]">
                <Bar
                  ref={alertsTypeChartRef}
                  data={alertsTypeChartData}
                  options={alertsTypeChartOptions}
                />
              </div>
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No alerts generated yet to build this breakdown.
              </div>
            )}
          </ChartCard>
        </div>

        {/* Charts row 4 */}
        <div className="grid gap-3 md:grid-cols-2">
          <ChartCard
            title="Top usernames"
            description="Usernames ranked by number of normalized events in the selected window."
            chartRef={userChartRef}
            filename="mini-siem-top-users.png"
            footerSummary={topUsersSummary}
            contextLabel={baseContextLabel}
          >
            {topUsers.length > 0 ? (
              <Bar
                ref={userChartRef}
                data={userChartData}
                options={userChartOptions}
              />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No username information available in the current window.
              </div>
            )}
          </ChartCard>

          <ChartCard
            title="Auth failures by username"
            description="Usernames ranked by number of failed auth events in the selected window."
            chartRef={failUserChartRef}
            filename="mini-siem-auth-failures-by-user.png"
            footerSummary={authFailuresSummary}
            contextLabel={baseContextLabel}
          >
            {authFailuresByUser.length > 0 ? (
              <Bar
                ref={failUserChartRef}
                data={authFailuresChartData}
                options={authFailuresChartOptions}
              />
            ) : (
              <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
                No failed authentication events detected in the current window.
              </div>
            )}
          </ChartCard>
        </div>

        {/* Charts row 5 */}
        <ChartCard
          title="Top alerting entities"
          description="Entities most frequently associated with generated alerts (IP/user/etc.)."
          chartRef={topAlertEntitiesRef}
          filename="mini-siem-top-alert-entities.png"
          footerSummary={topAlertEntitiesSummary}
          contextLabel={baseContextLabel}
        >
          {topAlertEntities.length > 0 ? (
            <Bar
              ref={topAlertEntitiesRef}
              data={topAlertEntitiesData}
              options={topAlertEntitiesOptions}
            />
          ) : (
            <div className="flex h-full items-center justify-center text-[0.7rem] text-slate-500">
              No alert entities available in the current window.
            </div>
          )}
        </ChartCard>

        <p className="text-[0.65rem] text-slate-500 italic">
          Overview charts are computed locally in your browser from 
          normalized events and the selected time window. No data leaves your device. 
          Exported PNGs include a small attribution footer.
        </p>
      </div>
    </div>
  )
}

export default MiniSiemOverviewTab
